/*
 * Copyright (C) 2023  Steffen Nuessle
 * 
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

#include "Generator.hpp"

#include "ASTVisitor.hpp"
#include "util/Decl.hpp"
#include "util/commandline.hpp"

Generator::Generator(std::shared_ptr<const Config> Config,
                     clang::PrintingPolicy Policy,
                     llvm::StringRef Backend)
    : clang::ASTConsumer(),
      Config_(std::move(Config)),
      PrintingPolicy_(Policy),
      Buffer_(),
      Out_(Buffer_),
      Functions_(),
      Methods_(),
      Variables_(),
      Backend_(Backend)
{
    Buffer_.reserve(BUFSIZ);
}

void Generator::HandleTranslationUnit(clang::ASTContext &Context)
{
    auto Visitor = ASTVisitor(Config_, Context);
    (void) Visitor.TraverseDecl(Context.getTranslationUnitDecl());

    auto &Result = Visitor.result();

    auto N = Result.Decls.size();
    Functions_.reserve(N);
    Methods_.reserve(N);
    Variables_.reserve(N);

    AnyVariadic_ = Result.AnyVariadic;

    for (auto Decl : Result.Decls) {
        switch (Decl->getKind()) {
        case clang::Decl::Function:
            Functions_.push_back(llvm::cast<const clang::FunctionDecl>(Decl));
            break;
        case clang::Decl::CXXMethod:
            Methods_.push_back(llvm::cast<const clang::CXXMethodDecl>(Decl));
            break;
        case clang::Decl::Var:
            Variables_.push_back(llvm::cast<const clang::VarDecl>(Decl));
            break;
        default:
            break;
        }
    }

    writeFileHeader();
    run();
    write();
}

void Generator::writeFileHeader()
{
    /* clang-format off */
    Out_ << 
"/*\n"
" * Generated by ccmock " CCMOCK_VERSION_CORE " <" CCMOCK_WEBSITE ">\n"
" *\n";

    if (Config_->General.WriteDate) {
        /* Looks like I do not understand std::chrono... */
        char buf[64];
        struct tm tm;

        auto Now = std::time(nullptr);
        (void) gmtime_r(&Now, &tm);

        std::strftime(buf, std::size(buf), "%FT%T%z", &tm);

        Out_ << 
" *     Date        : " << buf << "\n";
    }

    auto &Base = Config_->General.BaseDirectory;
    auto Input = std::filesystem::relative(Config_->General.Input, Base);
    auto Output = std::filesystem::relative(Config_->General.Output, Base);
    
    if (Output.empty())
        Output = "-";

    Out_ <<
" *     Backend     : " << Backend_ << "\n"
" *     Input       : " << Input << "\n"
" *     Output      : " << Output << "\n"
" *     Directory   : " << Base << "\n"
" */\n";

    /* clang-format off */
}

void Generator::write() const
{
    std::error_code error;

    if (Config_->General.Output.empty()) {
        llvm::outs() << Buffer_ << "\n";
        return;
    }

    auto Out = llvm::raw_fd_stream(Config_->General.Output.native(), error);
    if (error) {
        llvm::errs() << util::cl::error() 
                     << "failed to open \""
                     << Config_->General.Output.native()
                     << "\": " << error.message() << "\n";
        std::exit(EXIT_FAILURE);
    }

    Out << Buffer_ << "\n";
}

void Generator::writeMacroDefinitions()
{
    Out_ << R"(
#ifdef __cplusplus
#define CCMOCK_DECL extern "C"
#else
#define CCMOCK_DECL
#endif

)";
}

void Generator::writeGlobalVariables()
{
    for (auto &Decl : Variables_) {
        auto Type = Decl->getType();

        /* 
         * These variable declarations here will all be declared with
         * "extern" so we have to remove it. Also some might have
         * gcc attributes assigned to them which also need to be removed.
         * To make this work with function pointer definitions, it is
         * the easiest to create a new VarDecl and let clang to the printing.
         */
        auto Pointee = Type->getPointeeType();
        if (Pointee.isNull() || !Pointee->isFunctionType()) {
            writeType(Type);
            Out_ << " " << *Decl << ";\n";
            continue;
        }
        
        auto &Context = Decl->getASTContext();
        auto VarDecl = util::decl::fakeVarDecl(Context, Type, Decl->getName());
        VarDecl->print(Out_, PrintingPolicy_);
        Out_ << ";\n";
    }

    if (!Variables_.empty())
        Out_ << "\n";
}

void Generator::writeFunctionParameterList(const clang::FunctionDecl *Decl)
{
    auto Parameters = Decl->parameters();

    if (Parameters.empty()) {
        if (PrintingPolicy_.UseVoidForZeroParams)
            Out_ << "(void)";
        else
            Out_ << "()";

        return;
    }

    Out_ << "(";

    for (unsigned int i = 0, Size = Parameters.size(); i < Size; ++i) {
        if (i != 0)
            Out_ << ", ";

        /* Ensure that every parameter will have a name associated to it */
        if (!Parameters[i]->getName().empty()) {
            Parameters[i]->print(Out_, PrintingPolicy_);
            continue;
        }

        auto Type = Parameters[i]->getType();
        auto Pointee = Type->getPointeeType();

        if (Pointee.isNull() || !Pointee->isFunctionType()) {
            Type.print(Out_, PrintingPolicy_);

            /*
             * We need to be aware of something like "char *const ptr;".
             * Just checking for "isPointerType()" or "isReferenceType()" to
             * determine whether we need to append a space character or not is
             * not sufficient to correctly print such a type declaration.
             */
            if (auto C = Buffer_.back(); C != '&' && C != '*')
                Out_ << " ";

            Out_ << "arg" << i + 1;

            continue;
        }

        /*
         * Function pointers or references can be extremely tricky to print
         * as the name of the corresponding variable is surrounded by its own
         * type, e.g.:
         *      void *(*func)(void (*)(int, int))
         *             ^~~~
         * We therefore create a new VarDecl (which is obviously not part of
         * the parsed source code) with an appropriate name and then let
         * clang's "Decl::print" function do the heavy lifting.
         */
        std::string Name;
        llvm::raw_string_ostream OS(Name);

        OS << "arg" << i + 1;

        auto &Context = Decl->getASTContext();
        auto VarDecl = util::decl::fakeVarDecl(Context, Type, Name);
        VarDecl->print(Out_, PrintingPolicy_);
    }

    if (Decl->isVariadic())
        Out_ << ", ...";

    Out_ << ")";
}


