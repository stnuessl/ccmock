/*
 * Copyright (C) 2022   Steffen Nuessle
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "Generator.hpp"

#include "ASTVisitor.hpp"
#include "util/Decl.hpp"
#include "util/commandline.hpp"

Generator::Generator(std::shared_ptr<const Config> Config,
                     clang::PrintingPolicy Policy,
                     llvm::StringRef Backend)
    : clang::ASTConsumer(),
      Config_(std::move(Config)),
      PrintingPolicy_(Policy),
      Buffer_(),
      Out_(Buffer_),
      Functions_(),
      Methods_(),
      Variables_(),
      Backend_(Backend)
{
    Buffer_.reserve(BUFSIZ);
}

void Generator::HandleTranslationUnit(clang::ASTContext &Context)
{
    auto Visitor = ASTVisitor(Config_, Context);
    (void) Visitor.TraverseDecl(Context.getTranslationUnitDecl());

    auto &Result = Visitor.result();

    auto N = Result.Decls.size();
    Functions_.reserve(N);
    Methods_.reserve(N);
    Variables_.reserve(N);

    AnyVariadic_ = Result.AnyVariadic;

    for (auto Decl : Result.Decls) {
        switch (Decl->getKind()) {
        case clang::Decl::Function:
            Functions_.push_back(llvm::cast<const clang::FunctionDecl>(Decl));
            break;
        case clang::Decl::CXXMethod:
            Methods_.push_back(llvm::cast<const clang::CXXMethodDecl>(Decl));
            break;
        case clang::Decl::Var:
            Variables_.push_back(llvm::cast<const clang::VarDecl>(Decl));
            break;
        default:
            break;
        }
    }

    writeFileHeader();
    run();
    write();
}

void Generator::writeFileHeader()
{
    /* clang-format off */
    Out_ << 
"/*\n"
" * Generated by ccmock " CCMOCK_VERSION_CORE " <" CCMOCK_WEBSITE ">\n"
" *\n";

    if (Config_->General.WriteDate) {
        /* Looks like I do not understand std::chrono... */
        char buf[64];
        struct tm tm;

        auto Now = std::time(nullptr);
        (void) gmtime_r(&Now, &tm);

        std::strftime(buf, std::size(buf), "%FT%T%z", &tm);

        Out_ << 
" *     Date        : " << buf << "\n";
    }

    auto &Base = Config_->General.BaseDirectory;
    auto Input = std::filesystem::relative(Config_->General.Input, Base);
    auto Output = std::filesystem::relative(Config_->General.Output, Base);
    
    if (Output.empty())
        Output = "-";

    Out_ <<
" *     Backend     : " << Backend_ << "\n"
" *     Input       : " << Input << "\n"
" *     Output      : " << Output << "\n"
" *     Directory   : " << Base << "\n"
" */\n";

    /* clang-format off */
}

void Generator::write() const
{
    std::error_code error;

    if (Config_->General.Output.empty()) {
        llvm::outs() << Buffer_ << "\n";
        return;
    }

    auto Out = llvm::raw_fd_stream(Config_->General.Output.native(), error);
    if (error) {
        llvm::errs() << util::cl::error() 
                     << "failed to open \""
                     << Config_->General.Output.native()
                     << "\": " << error.message() << "\n";
        std::exit(EXIT_FAILURE);
    }

    Out << Buffer_ << "\n";
}

void Generator::writeGlobalVariables()
{
    for (auto &Decl : Variables_) {
        auto Type = Decl->getType();

        /* 
         * These variable declarations here will all be declared with
         * "extern" so we have to remove it. Also some might have
         * gcc attributes assigned to them which also need to be removed.
         * To make this work with function pointer definitions, it is
         * the easiest to create a new VarDecl and let clang to the printing.
         */
        auto Pointee = Type->getPointeeType();
        if (Pointee.isNull() || !Pointee->isFunctionType()) {
            Type.print(Out_, PrintingPolicy_);
            Out_ << " " << *Decl << ";\n";
            continue;
        }
        
        auto &Context = Decl->getASTContext();
        auto VarDecl = util::decl::fakeVarDecl(Context, Type, Decl->getName());
        VarDecl->print(Out_, PrintingPolicy_);
        Out_ << ";\n";
    }

    if (!Variables_.empty())
        Out_ << "\n";
}
