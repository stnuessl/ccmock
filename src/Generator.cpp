/*
 * Copyright (C) 2023  Steffen Nuessle
 * 
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

#include "Generator.hpp"

#include "ASTVisitor.hpp"
#include "util/Decl.hpp"
#include "util/commandline.hpp"

Generator::Generator(std::shared_ptr<const Config> Config,
                     clang::PrintingPolicy Policy,
                     llvm::StringRef Backend)
    : clang::ASTConsumer(),
      Config_(std::move(Config)),
      PrintingPolicy_(Policy),
      Buffer_(),
      Out_(Buffer_),
      FuncDeclVec_(),
      VarDeclVec_(),
      AnyVariadic_(false),
      Backend_(Backend)
{
    Buffer_.reserve(BUFSIZ);
}

void Generator::HandleTranslationUnit(clang::ASTContext &Context)
{
    auto Result = ASTVisitor::run(Config_, Context);

    FuncDeclMap_ = std::move(Result.FuncDeclMap);
    VarDeclVec_ = std::move(Result.VarDeclVec);

    AnyVariadic_ = Result.AnyVariadic;
    
    writeFileHeader();
    run();
    write();
}

/* 
 * clang provides its own clang::getOperatorSpelling function but some 
 * returned strings there are not usable as C++ identifiers.
 */
llvm::StringRef Generator::getMockName(const clang::FunctionDecl *Decl)
{
    switch (Decl->getKind()) {
    case clang::Decl::CXXConstructor:
        return "constructor";
    case clang::Decl::CXXDestructor:
        return "destructor";
    default:
        break;
    }

    switch (Decl->getOverloadedOperator())  {
    case clang::OO_None:
        return Decl->getName();
    case clang::OO_New:
        return "op_new";
    case clang::OO_Delete:
        return "op_delete";
    case clang::OO_Array_New:
        return "op_array_new";
    case clang::OO_Array_Delete:
        return "op_array_delete";
    case clang::OO_Plus:
        return "op_plus";
    case clang::OO_Minus:
        return "op_minus";
    case clang::OO_Star:
        return "op_star";
    case clang::OO_Slash:
        return "op_slash";
    case clang::OO_Percent:
        return "op_percent";
    case clang::OO_Caret:
        return "op_caret";
    case clang::OO_Amp:
        return "op_amp";
    case clang::OO_Pipe:
        return "op_pipe";
    case clang::OO_Tilde:
        return "op_tilde";
    case clang::OO_Exclaim:
        return "op_exclaim";
    case clang::OO_Equal:
        return "op_equal";
    case clang::OO_Less:
        return "op_less";
    case clang::OO_Greater:
        return "op_greater";
    case clang::OO_PlusEqual:
        return "op_plus_equal";
    case clang::OO_MinusEqual:
        return "op_minus_equal";
    case clang::OO_StarEqual:
        return "op_star_equal";
    case clang::OO_SlashEqual:
        return "op_slash_equal";
    case clang::OO_PercentEqual:
        return "op_percent_equal";
    case clang::OO_CaretEqual:
        return "op_caret_equal";
    case clang::OO_AmpEqual:
        return "op_amp_equal";
    case clang::OO_PipeEqual:
        return "op_pipe_equal";
    case clang::OO_LessLess:
        return "op_less_less";
    case clang::OO_GreaterGreater:
        return "op_greater_greater";
    case clang::OO_LessLessEqual:
        return "op_less_less_equal";
    case clang::OO_GreaterGreaterEqual:
        return "op_greater_greater_equal";
    case clang::OO_EqualEqual:
        return "op_equal_equal";
    case clang::OO_ExclaimEqual:
        return "op_exclaim_equal";
    case clang::OO_LessEqual:
        return "op_less_equal";
    case clang::OO_GreaterEqual:
        return "op_greater_equal";
    case clang::OO_Spaceship:
        return "op_spaceship";
    case clang::OO_AmpAmp:
        return "op_amp_amp";
    case clang::OO_PipePipe:
        return "op_pipe_pipe";
    case clang::OO_PlusPlus:
        return "op_plus_plus";
    case clang::OO_MinusMinus:
        return "op_minus_minus";
    case clang::OO_Comma:
        return "op_comma";
    case clang::OO_ArrowStar:
        return "op_arrow_star";
    case clang::OO_Arrow:
        return "op_arrow";
    case clang::OO_Call:
        return "op_call";
    case clang::OO_Subscript:
        return "op_subscript";
    default:
        llvm_unreachable("unknown overloaded operator");
        break;
    }

    return "";
}

void Generator::writeFileHeader()
{
    /* clang-format off */
    Out_ << 
"/*\n"
" * Generated by ccmock " CCMOCK_VERSION_CORE " <" CCMOCK_WEBSITE ">\n"
" *\n";

    if (Config_->General.WriteDate) {
        /* Looks like I do not understand std::chrono... */
        constexpr std::size_t buf_size = 64;
        auto buf = std::array<char, buf_size>();
        struct tm tm = ::tm();

        auto Now = std::time(nullptr);
        (void) gmtime_r(&Now, &tm);

        auto size = std::strftime(buf.data(), std::size(buf), "%FT%T%z", &tm);

        Out_ << 
" *     Date        : " << std::string_view(buf.data(), size)  << "\n";
    }

    auto &Base = Config_->General.BaseDirectory;
    auto Input = std::filesystem::relative(Config_->General.Input, Base);
    auto Output = std::filesystem::relative(Config_->General.Output, Base);
    
    if (Output.empty())
        Output = "-";

    Out_ <<
" *     Backend     : " << Backend_ << "\n"
" *     Directory   : " << Base << "\n"
" *     Input       : " << Input << "\n"
" *     Output      : " << Output << "\n"
" */\n";

    /* clang-format off */
}

void Generator::write() const
{
    auto &Path = Config_->General.Output.native();

    if (Path.empty()) {
        llvm::outs() << Buffer_ << "\n";
    } else {
        std::error_code error;

        auto Out = llvm::raw_fd_ostream(Path, error);
        if (error) {
            llvm::errs() << util::cl::error() 
                         << "failed to open \""
                         << Config_->General.Output.native()
                         << "\": " << error.message() << "\n";
            std::exit(EXIT_FAILURE);
        }

        Out << Buffer_ << "\n";
    }
    
    if (Config_->General.Verbose) {
        llvm::errs() << util::cl::info()
                     << "wrote " << Buffer_.size() + 1 << " bytes to ";

        if (Path.empty())
            llvm::errs() << "standard output\n";
        else
            llvm::errs() << "\"" << Path << "\"\n";
    }
}

void Generator::writeMacroDefinitions()
{
    Out_ << R"(
#ifdef __cplusplus
#define CCMOCK_DECL extern "C"
#else
#define CCMOCK_DECL
#endif

)";
}

void Generator::writeGlobalVariables()
{
    for (auto &Decl : VarDeclVec_) {
        auto Type = Decl->getType();

        /* 
         * These variable declarations here will all be declared with
         * "extern" so we have to remove it. Also some might have
         * gcc attributes assigned to them which also need to be removed.
         * To make this work with function pointer definitions, it is
         * the easiest to create a new VarDecl and let clang to the printing.
         */
        auto Pointee = Type->getPointeeType();
        if (Pointee.isNull() || !Pointee->isFunctionType()) {
            writeType(Type);
            Out_ << " " << *Decl << ";\n";
            continue;
        }
        
        auto &Context = Decl->getASTContext();
        auto *VarDecl = util::decl::fakeVarDecl(Context, Type, Decl->getName());
        VarDecl->print(Out_, PrintingPolicy_);
        Out_ << ";\n";
    }

    if (!VarDeclVec_.empty())
        Out_ << "\n";
}

void Generator::writeFunctionParameterList(const clang::FunctionDecl *Decl, bool ParameterNames, bool VarArgList)
{
    auto Parameters = Decl->parameters();

    if (Parameters.empty()) {
        if (PrintingPolicy_.UseVoidForZeroParams)
            Out_ << "(void)";
        else
            Out_ << "()";

        return;
    }

    Out_ << "(";

    for (unsigned int i = 0, Size = Parameters.size(); i < Size; ++i) {
        if (i != 0)
            Out_ << ", ";

        if (!ParameterNames) {
            writeType(Parameters[i]->getType());
            continue;
        }

        /* Ensure that every parameter will have a name associated to it */
        if (!Parameters[i]->getName().empty()) {
            Parameters[i]->print(Out_, PrintingPolicy_);
            continue;
        }

        auto Type = Parameters[i]->getType();
        auto Pointee = Type->getPointeeType();

        if (Pointee.isNull() || !Pointee->isFunctionType()) {
            writeType(Type);

            /*
             * We need to be aware of something like "char *const ptr;".
             * Just checking for "isPointerType()" or "isReferenceType()" to
             * determine whether we need to append a space character or not is
             * not sufficient to correctly print such a type declaration.
             */
            if (auto C = Buffer_.back(); C != '&' && C != '*')
                Out_ << " ";

            Out_ << "arg" << i + 1;

            continue;
        }

        /*
         * Function pointers or references can be extremely tricky to print
         * as the name of the corresponding variable is surrounded by its own
         * type, e.g.:
         *      void *(*func)(void (*)(int, int))
         *             ^~~~
         * We therefore create a new VarDecl (which is obviously not part of
         * the parsed source code) with an appropriate name and then let
         * clang's "Decl::print" function do the heavy lifting.
         */
        std::string Name;
        llvm::raw_string_ostream OS(Name);

        OS << "arg" << i + 1;

        auto &Context = Decl->getASTContext();
        auto *VarDecl = util::decl::fakeVarDecl(Context, Type, Name);
        VarDecl->print(Out_, PrintingPolicy_);
    }

    if (Decl->isVariadic()) {
        if (VarArgList)
            Out_ << ", va_list";
        else
            Out_ << ", ...";
    }

    Out_ << ")";
}


