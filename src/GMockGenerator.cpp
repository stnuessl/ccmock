/*
 * Copyright (C) 2022   Steffen Nuessle
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <iomanip>
#include <time.h>

#include <clang/Basic/SourceManager.h>
#include <clang/Basic/Version.h>
#include <llvm/Config/llvm-config.h>

#include "ASTVisitor.hpp"
#include "GMockGenerator.hpp"

#include "util/Decl.hpp"
#include "util/Type.hpp"
#include "util/commandline.hpp"

GMockGenerator::GMockGenerator(std::shared_ptr<const Config> Config,
                               clang::PrintingPolicy Policy)
    : Config_(std::move(Config)), Buffer_(), Out_(Buffer_),
      PrintingPolicy_(Policy)
{
    Buffer_.reserve(BUFSIZ);

    /* There is not much choice here as the gmock library is  written in C++ */
    PrintingPolicy_.adjustForCPlusPlus();
}

void GMockGenerator::HandleTranslationUnit(clang::ASTContext &Context)
{
    auto Visitor = ASTVisitor();
    Visitor.setConfig(Config_);
    Visitor.setSourceManager(&Context.getSourceManager());

    (void) Visitor.TraverseDecl(Context.getTranslationUnitDecl());

    auto Vec = Visitor.takeFunctionDecls();

    auto GlobalFunctionDeclVec = std::vector<const clang::FunctionDecl *>();

    for (const auto Item : Vec) {
        if (util::decl::isGlobalFunction(Item))
            GlobalFunctionDeclVec.push_back(Item);
    }

    writeCommentHeader(Context);
    writeIncludeStatements();
    writeGlobalFunctionMocks(GlobalFunctionDeclVec);
    writeClassMethodMocks();
    writeMainFunctionDefinition();

    dumpMocks();
}

void GMockGenerator::dumpMocks()
{
    std::error_code error;

    if (Config_->Output.empty()) {
        llvm::outs() << Out_.str() << "\n";
        return;
    }

    auto outs = llvm::raw_fd_stream(Config_->Output, error);
    if (error) {
        llvm::errs() << util::cl::error() << "failed to open \""
                     << Config_->Output << "\": " << error.message() << "\n";
        std::exit(EXIT_FAILURE);
    }

    outs << Buffer_ << "\n";
}

void GMockGenerator::writeCommentHeader(const clang::ASTContext &Context)
{
    auto &SourceManager = Context.getSourceManager();
    auto FileID = SourceManager.getMainFileID();
    auto Entry = SourceManager.getFileEntryForID(FileID);

    llvm::StringRef Output = "-";
    if (!Config_->Output.empty())
        Output = Config_->Output;

    /* clang-format off */
    Out_ << 
"/*\n"
" * This file was automatically generated by ccmock " CCMOCK_VERSION_CORE ".\n"
" * Information about ccmock is available at " CCMOCK_WEBSITE ".\n"
" *\n";

    if (Config_->WriteDate) {
        /* Looks like I do not understand std::chrono... */
        char buf[64];
        struct tm tm;

        auto Now = std::time(nullptr);
        gmtime_r(&Now, &tm);

        std::strftime(buf, std::size(buf), "%FT%T%z", &tm);

        Out_ << 
" *     Date        : " << buf << "\n";
    }

        Out_ << 
" *     Input       : " << Entry->getName() << "\n"
" *     Output      : " << Output << "\n";

    Out_ <<
R"( *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
)";
    /* clang-format on */
}

void GMockGenerator::writeIncludeStatements()
{
    Out_ << R"(
#include <gmock/gmock.h>
#include <gtest/gtest.h>

)";
}

void GMockGenerator::writeGlobalFunctionMocks(
    const std::vector<const clang::FunctionDecl *> &Vec)
{
    if (Vec.empty())
        return;

    Out_ << "class " << Config_->MockName
         << " {\n"
            "public:\n";

    for (const auto FunctionDecl : Vec) {
        if (FunctionDecl->isVariadic()) {
            if (Config_->Strict) {
                llvm::errs()
                    << util::cl::error() << "encounterd variadic function \""
                    << *FunctionDecl << "\"\n";
                std::exit(EXIT_FAILURE);
            }

            llvm::errs() << util::cl::warning()
                         << "skipping variadic function \"" << *FunctionDecl
                         << "\"\n";
            continue;
        }
        /*
         * TODO: Solution if multiple functions with same name in different
         * namespaces exists.
         */

        /*
         * Example output:
         *      MOCK_METHOD((ReturnType), FunctionName, ((Parameters));
         */
        Out_ << "    MOCK_METHOD((";
        FunctionDecl->getReturnType().print(Out_, PrintingPolicy_);
        Out_ << "), " << *FunctionDecl << ", ";
        writeParameterList(FunctionDecl);
        Out_ << ");\n";
    }

    Out_ << "};\n\n";

    auto MockType = llvm::StringRef("StrictMock");
    if (!Config_->MockType.empty())
        MockType = Config_->MockType;

    /*
     * Example output:
     *      static testing::StrictMock<MockName> MockName;
     */
    Out_ << "static testing::" << MockType << "<" << Config_->MockName << "> "
         << Config_->MockName << ";\n\n";

    bool PrevExternC = false;

    /* Write the mock function definitions */
    for (const auto FunctionDecl : Vec) {
        bool ExternC = FunctionDecl->isExternC();

        if (PrevExternC != ExternC) {
            writeCLinkage(ExternC);
            PrevExternC = ExternC;
        }

        FunctionDecl->print(Out_, PrintingPolicy_);
        Out_ << "\n";
        writeFunctionBody(FunctionDecl);
        Out_ << "\n";
    }

    if (PrevExternC)
        writeCLinkage(false);
}

void GMockGenerator::writeClassMethodMocks()
{
}

void GMockGenerator::writeMainFunctionDefinition()
{
    if (!Config_->WriteMain)
        return;

    /* clang-format off */
    Out_ <<
R"(
int main(int argc, char *argv[])
{
    testing::InitGoogleTest(&argc, argv);

    return RUN_ALL_TESTS();
}
)";
    /* clang-format on */
}

void GMockGenerator::writeParameterList(const clang::FunctionDecl *Decl)
{
    auto Parameters = Decl->parameters();

    if (Parameters.empty()) {
        if (PrintingPolicy_.UseVoidForZeroParams)
            Out_ << "(void)";
        else
            Out_ << "()";

        return;
    }

    auto Last = Parameters.size() - 1;

    Out_ << "(";

    for (unsigned int i = 0; i < Last; ++i) {
        Parameters[i]->print(Out_, PrintingPolicy_);

        Out_ << ", ";
    }

    Parameters.back()->print(Out_, PrintingPolicy_);
    Out_ << ")";
}

void GMockGenerator::writeFunctionSpecifiers(const clang::FunctionDecl *Decl)
{
    (void) Decl;
}

void GMockGenerator::writeCLinkage(bool Start)
{
    Out_ << "#ifdef __cplusplus\n";

    if (Start)
        Out_ << "extern \"C\" {\n";
    else
        Out_ << "}\n";

    Out_ << "#endif\n";
}

void GMockGenerator::writeFunctionBody(const clang::FunctionDecl *Decl)
{
    auto Parameters = Decl->parameters();
    auto Last = Parameters.size() - 1;

    /*
     * Output has to look something like:
     *      {
     *          return mock.func(arg1, arg2);
     *      }
     */
    Out_ << "{\n"
            "   return "
         << Config_->MockName << "." << *Decl << "(";

    for (unsigned int i = 0; i < Last; ++i) {
        Out_ << *Parameters[i] << ", ";
    }

    Out_ << *Parameters.back()
         << ");\n"
            "}\n";
}
