/*
 * Copyright (C) 2022   Steffen Nuessle
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <ctime>

#include <clang/Basic/SourceManager.h>
#include <clang/Basic/Version.h>

#include <llvm/Config/llvm-config.h>
#include <llvm/Support/Process.h>

#include "ASTVisitor.hpp"
#include "GMockGenerator.hpp"

#include "util/Decl.hpp"
#include "util/Type.hpp"
#include "util/commandline.hpp"

GMockGenerator::GMockGenerator(std::shared_ptr<const Config> Config,
                               clang::PrintingPolicy Policy)
    : Config_(std::move(Config)),
      Buffer_(),
      Out_(Buffer_),
      PrintingPolicy_(Policy)
{
    Buffer_.reserve(BUFSIZ);

    /* There is not much choice here as the gmock library is written in C++ */
    PrintingPolicy_.adjustForCPlusPlus();
}

void GMockGenerator::HandleTranslationUnit(clang::ASTContext &Context)
{
    auto Visitor = ASTVisitor();
    Visitor.setConfig(Config_);
    Visitor.setSourceManager(&Context.getSourceManager());

    (void) Visitor.TraverseDecl(Context.getTranslationUnitDecl());

    auto Vec = Visitor.takeFunctionDecls();

    auto GlobalFunctionDeclVec = std::vector<const clang::FunctionDecl *>();

    for (const auto Item : Vec) {
        if (util::decl::isGlobalFunction(Item))
            GlobalFunctionDeclVec.push_back(Item);
    }

    writeCommentHeader();
    writeIncludeStatements();
    writeGlobalFunctionMocks(GlobalFunctionDeclVec);
    writeClassMethodMocks();
    writeMainFunctionDefinition();

    dumpMocks();
}

void GMockGenerator::dumpMocks()
{
    std::error_code error;

    if (Config_->General.Output.empty()) {
        llvm::outs() << Buffer_ << "\n";
        return;
    }

    auto outs = llvm::raw_fd_stream(Config_->General.Output.native(), error);
    if (error) {
        llvm::errs() << util::cl::error() 
                     << "failed to open \""
                     << Config_->General.Output.native() 
                     << "\": " << error.message() << "\n";
        std::exit(EXIT_FAILURE);
    }

    outs << Buffer_ << "\n";
}

void GMockGenerator::writeCommentHeader()
{
    /* clang-format off */
    Out_ << 
"/*\n"
" * This file was automatically generated by ccmock " CCMOCK_VERSION_CORE ".\n"
" * Information about ccmock is available at " CCMOCK_WEBSITE ".\n"
" *\n";

    if (Config_->General.WriteDate) {
        /* Looks like I do not understand std::chrono... */
        char buf[64];
        struct tm tm;

        auto Now = std::time(nullptr);
        (void) gmtime_r(&Now, &tm);

        std::strftime(buf, std::size(buf), "%FT%T%z", &tm);

        Out_ << 
" *     Date        : " << buf << "\n";
    }

    auto &Base = Config_->General.BaseDirectory;
    auto Input = std::filesystem::relative(Config_->General.Input, Base);
    auto Output = std::filesystem::relative(Config_->General.Output, Base);
    
    if (Output.empty())
        Output = "-";

    Out_ <<
" *     Input       : " << Input << "\n"
" *     Output      : " << Output << "\n"
" *     Directory   : " << Base << "\n";

    Out_ <<
R"( *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
)";
    /* clang-format on */
}

void GMockGenerator::writeIncludeStatements()
{
    Out_ << R"(
#include <gmock/gmock.h>
#include <gtest/gtest.h>

)";
}

void GMockGenerator::writeGlobalFunctionMocks(
    const std::vector<const clang::FunctionDecl *> &Vec)
{
    if (Vec.empty())
        return;

    Out_ << "class " << Config_->GMock.MockName
         << " {\n"
            "public:\n";

    for (const auto FunctionDecl : Vec) {
        /*
         * TODO: Solution if multiple functions with same name in different
         * namespaces exists.
         */

        /*
         * Example output:
         *      MOCK_METHOD((ReturnType), FunctionName, ((Parameters));
         */
        Out_ << "    MOCK_METHOD((";
        FunctionDecl->getReturnType().print(Out_, PrintingPolicy_);
        Out_ << "), " << *FunctionDecl << ", ";
        writeParameterList(FunctionDecl, /* WriteParmVarNames */ false);
        Out_ << ");\n";
    }

    Out_ << "};\n\n";

    auto MockType = llvm::StringRef("StrictMock");
    if (!Config_->GMock.MockType.empty())
        MockType = Config_->GMock.MockType;

    /*
     * Example output:
     *      static testing::StrictMock<MockName> MockName;
     */
    Out_ << "static testing::" << MockType 
         << "<" << Config_->GMock.MockName << "> "
         << Config_->GMock.MockName << ";\n\n";

    /* Write the mock function definitions */
    for (const auto FunctionDecl : Vec) {
        if (FunctionDecl->isExternC())
            Out_ << "extern \"C\" ";

        auto Type = FunctionDecl->getReturnType();
        Type.print(Out_, PrintingPolicy_);

        if (!util::type::isPointerOrReference(Type))
            Out_ << " ";

        Out_ << *FunctionDecl;
        writeParameterList(FunctionDecl, /* WriteParmVarNames */ true);
        Out_ << "\n";
        writeFunctionBody(FunctionDecl);
        Out_ << "\n";
    }
}

void GMockGenerator::writeClassMethodMocks()
{
}

void GMockGenerator::writeMainFunctionDefinition()
{
    if (!Config_->GMock.WriteMain)
        return;

    /* clang-format off */
    Out_ <<
R"(
int main(int argc, char *argv[])
{
    testing::InitGoogleTest(&argc, argv);

    return RUN_ALL_TESTS();
}
)";
    /* clang-format on */
}

void GMockGenerator::writeParmVarDecl(const clang::ParmVarDecl *Decl,
                                      bool WriteParmVarName,
                                      llvm::StringRef Fallback)
{
    if (!WriteParmVarName) {
        Decl->getType().print(Out_, PrintingPolicy_);
        return;
    }

    if (!Decl->getName().empty()) {
        Decl->print(Out_, PrintingPolicy_);
        return;
    }

    auto Type = Decl->getType();

    if (!util::type::isPointerOrReference(Type)) {
        Type.print(Out_, PrintingPolicy_);

        if (!util::type::isPointerOrReference(Type))
            Out_ << " ";

        Out_ << Fallback;
        return;
    }

    /*
     * Function pointers or references can be extremely tricky to print
     * as the name of the corresponding variable is surrounded by its own
     * type, e.g.:
     *      void *(*func)(void (*)(int, int))
     *             ^~~~
     * We therefore create a new VarDecl (which is obviously not part of
     * the parsed source code) with an appropriate name and then let clang's
     * "Decl::print" function do the heavy lifting.
     */
    auto &ASTContext = Decl->getASTContext();
    auto Loc = clang::SourceLocation();

    auto &IdInfo = ASTContext.Idents.getOwn(Fallback);

    auto VarDecl = clang::VarDecl::Create(ASTContext,
                                          ASTContext.getTranslationUnitDecl(),
                                          Loc,
                                          Loc,
                                          &IdInfo,
                                          Type,
                                          nullptr,
                                          clang::StorageClass::SC_None);

    VarDecl->print(Out_, PrintingPolicy_);
}

void GMockGenerator::writeParameterList(const clang::FunctionDecl *Decl,
                                        bool WriteParmVarNames)
{
    std::string Fallback;
    llvm::raw_string_ostream FallbackOS(Fallback);
    auto Parameters = Decl->parameters();

    if (Parameters.empty()) {
        if (PrintingPolicy_.UseVoidForZeroParams)
            Out_ << "(void)";
        else
            Out_ << "()";

        return;
    }

    Out_ << "(";

    for (unsigned int i = 0, Size = Parameters.size(); i < Size; ++i) {
        if (i != 0)
            Out_ << ", ";

        Fallback.clear();
        FallbackOS << "arg" << i + 1;

        writeParmVarDecl(Parameters[i], WriteParmVarNames, Fallback);
    }

    Out_ << ")";
}

void GMockGenerator::writeFunctionSpecifiers(const clang::FunctionDecl *Decl)
{
    (void) Decl;
}

void GMockGenerator::writeFunctionBody(const clang::FunctionDecl *Decl)
{
    auto Parameters = Decl->parameters();

    /*
     * Example output:
     *  {
     *      return mock.func(arg1, arg2);
     *  }
     */
    Out_ << "{\n"
         << "    ";

    if (!Decl->getReturnType()->isVoidType())
        Out_ << "return ";

    Out_ << Config_->GMock.MockName << "." << *Decl << "(";

    for (unsigned int i = 0, Size = Parameters.size(); i < Size; ++i) {
        if (i != 0)
            Out_ << ", ";

        if (!Parameters[i]->getName().empty())
            Out_ << *Parameters[i];
        else
            Out_ << "arg" << i + 1;
    }

    Out_ << ");\n"
            "}\n";
}
